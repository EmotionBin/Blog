# Vue生命周期

Vue的生命周期是一个比较重要的概念，在开发过程中，会频繁的接触这些生命周期的钩子，有时候往往会遇到一些问题，就需要从Vue的生命周期钩子去一步一步的分析，才能找出问题的关键，本文将会详细的介绍Vue生命周期。  

----

## 生命周期图示

首先先来看一张Vue官网的生命周期图示：  

![Y3nzpF.png](https://s1.ax1x.com/2020/05/10/Y3nzpF.png)

这张图描述了从创建vue实例到实例销毁的过程，接下来会一步一步的慢慢解析各个过程的区别与作用  

----

### beforeCreate

从上图中可以看到，beforeCreate是Vue生命周期中的第一个钩子。new Vue()即创建了一个Vue实例，之后开始初始化事件以及生命周期，在接下来就到了beforeCreate这个钩子，那么beforeCreate到底可以干什么呢，我自己写了一个demo进行测试：  

```html
<div id="app">
  <h1 id="h1">{{msg}}</h1>
</div>
```
```javascript
const vm = new Vue({
  el:'#app',
  data:{
    msg:'ok'
  },
  beforeCreate(){
    console.log(this.msg);
    this.show();
  },
  methods:{
    show(){
      console.log('执行了show方法');
    }
  }
})
```

在beforeCreate这个钩子中，打印msg并执行了show方法，运行，F12观察控制台：  

![Y8EzFS.png](https://s1.ax1x.com/2020/05/10/Y8EzFS.png)

msg为undefined，并且找不到show这个方法，说明**在beforeCreate这个钩子中，data和methods中的数据还没有被初始化**  

----

### created

再看到官网的声明周期图示，经过了beforeCreate钩子之后，来到下一个生命周期钩子created：  

```html
<div id="app">
    <h1 id="h1">{{msg}}</h1>
</div>
```
```javascript
const vm = new Vue({
    el:'#app',
    data:{
      msg:'ok'
    },
    created(){
      console.log(this.msg);
      this.show();
    },
    methods:{
      show(){
        console.log('执行了show方法');
      }
    }
  })
```

在created这个钩子中，做了同样的事情，再次观察控制台：  

![Y8VGTK.png](https://s1.ax1x.com/2020/05/10/Y8VGTK.png)

成功打印了msg并执行了show方法，说明**在created这个钩子中，data和methods都已经被初始化好了，如果要调用methods中的方法，或者操作data中的数据，最早只能在created中操作**

----

### beforeMount

再下来来到了beforeMount钩子，此时data和methods都已经初始化完成，那么数据有没有被挂载到dom上呢，继续看：  

```html
<div id="app">
    <h1 id="h1">{{msg}}</h1>
</div>
```
```javascript
const vm = new Vue({
    el:'#app',
    data:{
      msg:'ok'
    },
    beforeMount(){
      console.log(document.getElementById('h1').innerText);
    }
  })
```

在beforeMount钩子中，想看看数据有没有被渲染到dom上，打印了dom中的innerText，观察控制台：

![Y8VWlj.png](https://s1.ax1x.com/2020/05/10/Y8VWlj.png)

可以看到dom中的数据并没有被渲染，它还是我们之前写的模板字符串，即{{msg}}，说明**在beforeMount这个钩子中，页面中的元素还没有被真正替换渲染，仍然是之前写的一些模板字符串**

----

### mounted

在beforeMount钩子之后，就是mounted钩子了，在这个页面中，数据应该已经被渲染到dom上了，继续实验测试：  

```html
<div id="app">
	<h1 id="h1">{{msg}}</h1>
</div>
```
```javascript
const vm = new Vue({
    el:'#app',
    data:{
      msg:'ok'
    },
    mounted(){
      console.log(document.getElementById('h1').innerText);
    }
  })
```

在mounted钩子中，做了同样的操作，观察控制台的结果：

![Y8ZPhD.png](https://s1.ax1x.com/2020/05/10/Y8ZPhD.png)

控制台输出了ok，这正是data中msg的值，数据已经被渲染到dom上了，说明**在mounted这个钩子中，页面中的模板字符串已经被真实的挂载渲染，用户可以看到已经渲染好的页面了**

----

### beforeUpdate

前面的阶段一直到mounted的时候，表示Vue实例已经被创建好了，创建的生命周期钩子已经执行完毕，接着来来到了运行的生命周期钩子beforeUpdate，值得注意的是，**beforeUpdate这个钩子只有在数据发生改变的时候才会触发**，继续进行实验：  

```html
<div id="app">
  <input type="button" value="修改msg" @click="msg = 'no'">
  <h1 id="h1">{{msg}}</h1>
</div>
```
```javascript
const vm = new Vue({
    el:'#app',
    data:{
      msg:'ok'
    },
    beforeUpdate(){
      console.log(`界面上元素的内容：${document.getElementById('h1').innerText}`);
      console.log(`data中msg的数据：${this.msg}`);
    }
  })
```

运行页面，打开控制台，点击修改msg的按钮，观察控制台的输出：  

![Y8eQVx.png](https://s1.ax1x.com/2020/05/10/Y8eQVx.png)

可以得出结论，**当执行beforeUpdate的时候，页面中的显示的数据还是旧的数据，此时data中的数据是最新的数据，页面尚未和最新的数据保持同步**

----

### updated

在updated这个钩子中，dom中的数据应该已经完成更新，和data中的数据保持一致，继续实验：  

```html
<div id="app">
  <input type="button" value="修改msg" @click="msg = 'no'">
  <h1 id="h1">{{msg}}</h1>
</div>
```
```javascript
const vm = new Vue({
    el:'#app',
    data:{
      msg:'ok'
    },
    updated(){
      console.log(`界面上元素的内容：${document.getElementById('h1').innerText}`);
      console.log(`data中msg的数据：${this.msg}`);
    }
  })
```

运行，打开控制台，点击按钮，观察控制台输出结果：  

![Y8eyRg.png](https://s1.ax1x.com/2020/05/10/Y8eyRg.png)

可以得出结论，**当执行updated的时候，页面和data中的数据已经保持同步了，都是最新的**

----

### beforeDestroy和destroyed

beforeDestroy和destroyed这两个钩子是销毁的时候所执行的，这里就偷懒没有演示了  

----

### 关于Vue生命周期总结

上面说了挺多的，对于每一个生命周期钩子都进行了说明和实验，下面将会给出一张图对所有过程进行总结：  

![Y3o2kD.png](https://s1.ax1x.com/2020/05/10/Y3o2kD.png)

----

## nextTick
1. 关于vue的nextTick
2. 为什么vue要异步渲染

参考：  
https://www.jianshu.com/p/a7550c0e164f  
https://www.jianshu.com/p/da2c68fe8aed  
https://cn.vuejs.org/v2/guide/reactivity.html#%E5%BC%82%E6%AD%A5%E6%9B%B4%E6%96%B0%E9%98%9F%E5%88%97  

----

## 结束语

以上就是我关于MVC和MVVM的一些理解，如果本文中有说的不正确的地方，欢迎大佬鞭策!

### 参考资料：
[b站-vue生命周期](https://www.bilibili.com/video/BV1sb411M7RT?p=1)  