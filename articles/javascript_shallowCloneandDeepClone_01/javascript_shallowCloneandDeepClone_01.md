# JS中的值类型和引用类型
# 注意，这里是草稿
1.值类型和引用类型
2.深拷贝和浅拷贝

# 深拷贝与浅拷贝

js 的深拷贝，浅拷贝问题在项目的开发过程中是频繁出现的。对于一个合格的前端开发者来说，对于深刻理解它们是必要的，并能合理使用深拷贝浅拷贝处理问题  

----

## 堆和栈

js 中的堆和栈都是存放临时数据的地方，声明了一些变量，这些变量就是存放在 js 的堆或者栈中  

**栈(stack)**是先进后出的一种数据结构，就像一个桶，后进去的先出来，它下面本来有的东西要等其他出来之后才能出来  

**堆(heap)**是在程序运行时，而不是在程序编译时，申请某个大小的内存空间，所以堆是**动态分配内存**的  

----

### 基本数据类型

js 的基本数据类型有 5 种，分别是 `String`、`Number`、`Boolean`、`null`、`undefined`  

基本数据类型又被称为**值类型**，因为它们是**存放在栈内存中的，从栈当中直接存取变量的值**  

来看一个例子，有一行语句 `var a = 1;`，声明了一个变量 `a` 并给它赋值为 1，那么在这个过程中究竟发生了什么  

![aucedH.png](https://s1.ax1x.com/2020/07/30/aucedH.png)  

变量 `a` 的值是 1，是值类型，所以它被存放在栈内存中，在栈内存中存放了一个 name 为 `a`，value 为 1 的变量  

接着，又有一行语句 `var b = a;`，声明了一个变量 `b`，并把变量 `a` 的值赋值给变量 `b`  

![auRBlt.png](https://s1.ax1x.com/2020/07/30/auRBlt.png)  

**值类型复制时，会在栈中创建一个新变量，然后把值复制给新变量**  

又有一行语句 `a = 2;`，把变量 `a` 的值修改为 2  

![aufS8s.png](https://s1.ax1x.com/2020/07/30/aufS8s.png)  

直接在占内存中把变量 `a` 的值修改为 2，此时 `a = 2;b = 1`，语句 `a === b` 的返回值是 `false`，很明显，它们的值不相等  

**总结:值类型的变量存放在栈内存中，并且它们相互都是独立的，互不干扰**

----

### 引用数据类型

js 的引用数据类型是 `Object` 类型，其中还包括 `Array`、`Function` 等  

**引用类型存放在栈内存和堆内存中，栈内存中存放的是它的地址，堆内存中存放它的值，栈内存中的地址指向堆内存中的值**  

这样说可能有点绕，来看一个例子，`var obj = {a:1};`，声明了一个变量 `obj`，它的值是一个对象，这个过程又发生了什么  

![au5uxs.png](https://s1.ax1x.com/2020/07/30/au5uxs.png)  

变量 `obj` 的值一个对象，所以它是引用类型，**它在栈内存中的值是一个地址(这里假设是0x0012ff7d)**，这个地址指向堆内存中的某一个位置，堆内存中存储的是这个变量真正的值，栈内存中存储的地址指向这个值  

`var obj1 = obj`，声明了一个变量 `obj1` 并把变量 `obj` 的值赋值给它  

![auo0UK.png](https://s1.ax1x.com/2020/07/30/auo0UK.png)  

**引用类型复制的是存储在栈中的地址指针，先在栈内存中创建一个新变量，再把地址指针赋值给这个变量，这个指针副本和原指针指向存储在堆中的同一个对象**  

由上图中可以看出，`obj1` 和 `obj` 存储的地址指针是同一个值，它们都指向了堆内存中的同一个地址  

`obj.a = 8`，把变量 `obj` 中的属性 `a` 改变为 8，继续看图  

![au7EOs.png](https://s1.ax1x.com/2020/07/30/au7EOs.png)  

`obj` 是对象是引用类型，它在栈内存中只存储地址，真正的值存储在堆内存中，所以修改属性 `a`的值实际上就是修改堆内存中的值  

修改过后可以发现，`obj` 和 `obj1` 在栈内存中存储的地址指针没有变化，只是堆内存中的值发生了变化，所以在修改过后，`obj = {a:8};obj1 = {a:8}`  

`var obj2 = {a:8}`，声明了一个变量 `obj2`，它是值是 `{a:8}`  

![aubsot.png](https://s1.ax1x.com/2020/07/30/aubsot.png)  

因为 `obj2` 是新声明的一个变量，它在栈内存中存储的值是另一个新的地址，这个地址指针指向了堆内存中的某一个地址，语句 `obj === obj1` 的返回值是 `true`，`obj === obj2` 的返回值是 `false`，因为**引用类型在比较值时，是比较栈内存中的地址**  

**总结!!!!!!!!!!!!!!!!!!!!!!!!!!!!!待补充**

----



