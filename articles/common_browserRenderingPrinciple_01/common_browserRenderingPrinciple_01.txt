浏览器渲染原理

1. 浏览器架构
  (1)浏览器组件
  (2)浏览器进程和线程

2.浏览器渲染过程与原理
  (1)浏览器怎样解析html文件

3.阻塞渲染

4.优化渲染性能
  (1)html中css文件和js文件的引入顺序



参考:
1.https://segmentfault.com/a/1190000012960187#item-3
2.https://www.zhihu.com/question/23250329
3.https://segmentfault.com/a/1190000022633988
4.https://juejin.im/post/5e143104e51d45414a4715f7
5.https://segmentfault.com/a/1190000012925872

# 浏览器渲染原理

## 进程和线程

**进程**是 CPU 资源分配的最小单位（是能拥有资源和独立运行的最小单位）  

**线程**是 CPU 调度的最小单位（是建立在进程基础上的一次程序运行单位）  

对于操作系统来说，一个任务就是一个进程，在一个进程内部，要同时做多件事，就需要同时运行多个**子任务**,我们把进程内的这些子任务称为线程，所以线程是跑在进程里面的  

----

## 浏览器的多进程架构

就拿`Chrome`来说，`Chrome`是多进程的，每新开一个Chrome网页就相当于开启了一个新的进程，每个tab网页都是一个独立的进程  

多进程的优点：

- 单个 tab 页面崩溃不会影响到整个浏览器
- 第三方插件崩溃也不会影响到整个浏览器
- 多进程可以充分利用现代 CPU 多核的优势
- 方便使用沙盒模型隔离插件等进程，提高浏览器稳定性

多进程的缺点：

- 每个新开的进程都会分配CPU、内存等资源，对设备要求较高，资源消耗大

----

## 浏览器的主要进程

`Chrome`的每一个页面都是一个独立的进程，在这个独立的进程中又存在多个进程，浏览器的进程主要包括以下四部分：

1. 主进程：负责浏览器界面的显示与交互。各个页面的管理,创建和销毁其他进程。网络的资源管理、下载等
2. 第三方插件进程：每种类型的插件对应一个进程,仅当使用该插件时才创建
3. GPU进程：最多只有一个,用于 3D 绘制等
4. 渲染进程：称为浏览器渲染进程或浏览器内核,内部是多线程的。主要负责页面渲染,脚本执行,事件处理等

![NSnb7T.png](https://s1.ax1x.com/2020/06/14/NSnb7T.png)

这些进程负责着浏览器运行时的各个角色，其中**渲染进程(也叫浏览器内核)**是重点  

----

## 浏览器渲染进程(浏览器内核)

`Chrome`的每一个页面都是一个独立的进程，在每个独立的进程下面，又会有不同的线程跑在这个进程中。渲染进程就是多线程的，它包括GUI渲染线程、JS引擎线程、事件触发线程、定时触发器线程、异步http请求线程  

![NSuOqP.png](https://s1.ax1x.com/2020/06/14/NSuOqP.png)

### GUI渲染线程

- 负责渲染浏览器界面,解析 `HTML` , `CSS` ,构建 `DOM` 树和 RenderObject 树,布局和绘制等
- 当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时,该线程就会执行
- 注意,GUI渲染线程与 JS 引擎线程是互斥的,当 JS 引擎执行时 GUI 线程会被挂起（相当于被冻结了）,GUI 更新会被保存在一个队列中等到 JS 引擎空闲时立即被执行

----

### JS 引擎线程

- `Javascript` 引擎,也称为 JS 内核,负责处理 `Javascript` 脚本程序（例如 V8 引擎）
- JS 引擎线程负责解析 `Javascript` 脚本,运行代码
- JS 引擎一直等待着任务队列中任务的到来,然后加以处理,一个 Tab 页（renderer 进程）中无论什么时候都只有一个 JS 线程在运行 JS 程序
- 注意,GUI 渲染线程与 JS 引擎线程是互斥的,所以如果 JS 执行的时间过长,这样就会造成页面的渲染不连贯,导致页面渲染加载阻塞

----

### 事件触发线程

- 归属于浏览器而不是JS引擎，用来控制事件循环（可以理解，JS引擎自己都忙不过来，需要浏览器另开线程协助）
- 当 JS 引擎执行代码块如 `setTimeOut` 时（也可来自浏览器内核的其他线程,如鼠标点击、AJAX 异步请求等）,会将对应任务添加到事件线程中
- 当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理
- 注意，由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行）

----

### 定时触发器线程

- 传说中的 `setInterval` 与 `setTimeout` 所在线程
- 浏览器定时计数器并不是由 `JavaScript` 引擎计数的,（因为 `JavaScript` 引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确）
- 因此通过单独线程来计时并触发定时（计时完毕后,添加到事件队列中,等待 JS 引擎空闲后执行）
- 注意,W3C 在 `HTML` 标准中规定,规定要求 `setTimeout` 中低于 4ms 的时间间隔算为 4ms

### 异步 http 请求线程

- `XMLHttpRequest` 在连接后是通过浏览器新开一个线程发起请求
- 将检测到状态变更时,如果设置有回调函数,异步线程就产生状态变更事件,将这个回调再放入事件队列中。再由 `JavaScript` 引擎执行

----

## 浏览器渲染过程