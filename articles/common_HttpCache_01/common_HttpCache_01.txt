# 前端也要懂Http缓存机制
记得在我刚工作刚做项目的时候，将更改过的文件更新到服务器上，打开项目网站刷新后发现更改并没有生效，查来查去也没查出问题，之后师傅对我说，你清空一下浏览器缓存，在我清空浏览器缓存之后，奇迹发生了，一切都恢复正常，那时候我就很郁闷，缓存是个啥东西，于是最近终于抽空看了一下浏览器缓存这一方面的知识，在我总结之后，搭建后台进行了测试，加深我对缓存的理解。  

----
## Http简介
浏览器和服务器之间通信是通过HTTP协议，HTTP协议永远都是客户端发起请求，服务器回送响应。模型如下：

![GOltde.png](https://s1.ax1x.com/2020/04/12/GOltde.png)

HTTP报文就是浏览器和服务器间通信时发送及响应的数据块。浏览器向服务器请求数据，发送请求(request)报文；服务器向浏览器返回数据，返回响应(response)报文。报文信息主要分为两部分：  

1. 报文头部：一些附加信息（cookie，缓存信息等），与缓存相关的规则信息，均包含在头部中
2. 数据主体部分：HTTP请求真正想要传输的数据内容

## 后台搭建与测试
这里我自己搭建了一个node.js后台，使用了express框架，首先是不添加任何缓存信息头，代码如下：

```javascript
		const express = require('express');
		const app = express();
		const port = 9527;
		const fs = require('fs');
		const path = require('path');

		app.get('/',(req,res) => {
			res.send(`<!DOCTYPE html>
			<html lang="en">
			<head>
				<title>Document</title>
			</head>
			<body>
				Http Cache Demo
				<script src="/demo.js"></script>
			</body>
			</html>`);
		});

		app.get('/demo.js',(req, res)=>{
			let jsPath = path.resolve(__dirname,'./static/js/demo.js');
			let cont = fs.readFileSync(jsPath);
			res.end(cont);
		});

		app.listen(port,()=>{
			console.log(`listen on ${port}`)  ; 
		});
```

可以看到请求结果如下：

![GOG6cn.png](https://s1.ax1x.com/2020/04/12/GOG6cn.png)

请求过程如下：

- 浏览器请求静态资源demo.js
- 服务器读取磁盘文件demo.js，返给浏览器

如果这时候浏览器再次发出请求，或者说以后会有很多次这样的请求，那么这个过程就要一直重复。  

看得出来这种请求方式的流量与请求次数有关，同时，缺点也很明显：
- 浪费用户流量
- 浪费服务器资源，服务器要读磁盘文件，然后发送文件到浏览器
- 浏览器要等待js下载并且执行后才能渲染页面，影响用户体验

接下来，在请求头中添加上缓存信息，添加了缓存头信息之后又会是怎样的结果呢？

## Http缓存分类
Http缓存可以分为两大类，强制缓存（也称强缓存）和协商缓存。两类缓存规则不同，强制缓存在缓存数据未失效的情况下，不需要再和服务器发生交互；而协商缓存，顾名思义，需要进行比较判断是否可以使用缓存。  

两类缓存规则可以同时存在，强制缓存优先级高于协商缓存，也就是说，当执行强制缓存的规则时，如果缓存生效，直接使用缓存，不再执行协商缓存规则。

### 强制缓存
#### Expires
